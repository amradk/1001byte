

puppet использует клиент-скрверную архитектуру а это значит что на каждом сервере должен быть установлен puppet-agent. Однако, необходимость установки клиента само по себе не является проблемой, сложность в другом в серверной части. Серверная часть puppet'а состоит из 3-х а точнее 5-ти компонент:
* ca сервер, нужен для авторизации клиентов,
* puppetserver отвечает на запросы клиентов, компилирует каталог и высылает его клиентам,
* puppetdb - REST API интервейс который позволяет читать и записывать факты,
* PostgreSQL - используется puppetdb как хранилище данных,
* r10k или libraruim - для обновления и закачки модулей на puppetserver.
Всю инфраструктуру, необходимую для работы puppet'а не очень просто поднять и необходимо поддерживать. Отказ любого компонента приводит к полной или частичной (например puppetdb может использоваться не во всех модулях) невозможности свести puppet на серверах. Кроме того при большем кол-ве серверов возникает необходимость маштабирования puppetserver'а. А еще желательно поддерживать на всех клиентах одинаковую версию puppet-agent. Puppet-agent работает в режиме демона и раз в несколько минут обращается к puppetserver'у за каталогом а затем выполняет его. Такой режим работы позволяет держать инфраструктуру в согласованном состоянии но иногда может вызывать проблемы. Иногда может возникнуть ситуация когда свести puppet нужно не на всем парке серверов а только на конкретной группе, например только в одном ДЦ. Выполнить такую задачу может быть не очень просто - как минимум нужно правильно организовать репозиторий с puppet-кодом (роли и профили вам помогут), можно держать по puppetserver'у на ДЦ или организовать отдельный environment с кодом для каждого ДЦ или придумать что-то еще. Для справедливости стоит сказать что puppetdb и соответственно и PostgreSQL не являются обязательными компонентами, все зависит от того какие модули вы используете и нужны ли экспортируемые ресурсы. Экспортируемые ресурсы штука весьма полезная и позволяет проделывать, например, следуещие:
* на сервере с бэкендом экспортировать адрес и порт,
* на сервере с балансировщиком собирать экспортируемые ресурсы определенного вида и автоматически добавлять новые бэкенды в пул и убирать старые. Но экспортируемые ресурсы требуют наличия puppetdb. 

Разница в терминологии:
* ansible module -> puppet resource
* ansible role -> puppet module

Код:
На мой взгляд puppet модули (в ansible роли) с forge.puppet.com чаще качественнее и серьезней относятся к идемпотентности чем роли с ansible galaxy.

Подход:
Puppet для описания желаемого состояния использует декларативный DSL, использование императивного подхода практически невозможно - разве что только с помощью ресурса (модуля в терминологии Ansible) exec (аналогом в Ansible мире наверно будет модуль shell). Использовать puppet ресурс exec стоит только в крайних случаях и при условии что вы полностью понимаете что делаете т.к. достичь идемпотентность может оказаться очень не просто. Как результат с помощью puppet'а невозможно выполнить действия вида: остановить сервер, поменять что-то, запустить сервер. В случае с Ansible из моей головы не выходит словосочетание "дырявая абстракция" вроде бы ansible тоже пытается привести систему в определенной в playbook'е состояние, правда путем выполнения императивных tasks. Т.е. для того чтобы написать хороший идемпотентный playbook или role Ansible требует(?) от автора чуть больше навыков и внимания нежели DSL Puppet'а. С другой стороны возможность императивного выполнения позволяет использовать Ansible для задач деплоя или обновления ПО в тех случаях когда Puppet непременим. Пример: за балансировщиком находится несколько бэкендов и нужно их поочередно (на этом этапе с Puppet'ом уже придется хорошенько поразмыслить) обновить, для чего потребуются последовательно несколько действий с каждым экземпляром:
1. убрать backend из пула балансировщика,
2. остановить сервис,
3. развернуть обновленную версию,
4. запустить сервис,
5. вернуть backend в пул балансировщика.
Или еще пример: пусть у нас есть несколько экземпляров СУБД PostgreSQL подключение к которой осуществляется через PgBouncer, клинты находят инстансы с помощью какой-либо службы service discovery (Consul). Нам нужно выполнить обновление версии PgBouncer на всех хостах для чего потребуется исполнить следующие шаги:
1. убрать pgbouncer из каталога service discovery чтобы избежать новых подключений,
2. остановить pgbouncer,
3. обновить версию,
4. запустить pgbouncer,
5. вернуть экземпляр в каталог service discovery.
С подобными задачами легко справиться используя Ansible т.к. последний способен выполнить задачи поочередно, содержит много различных опций для управления потоком выполнения т.е. выполнить обновления на всех сервер по одному за раз, прекратить обновление если произошла ошибка хоть на одном хосте или на некотором кол-ве и так далее. Конечно подобную задачу можно выполнить и с помощью Puppet но придется выполнить много дополнительной и иногда ручной работы:
* остановить puppet агенты на серверах на которых планируем обновление с целью избежать нежалательного с ведения (например чтобы из пула не выпало слишком много экземпляров сервиса),
* подготовить манифест для обновляемого сервиса
* подготовить манифест для балансировщика или вручную убрать обновляемый экземпляр из каталога, ДНС и т.д.,
* свести puppet на обновляемом экземпляре,
* повторить пока не обновим все экземпляры.
Т.е. Ansible хорошо подходит для автоматизации часто повторяющихся задач, процессов деплоя, редких но сложных задач, состоящих из множества шагов. Puppet для подобных целей мало пригоден, хотя я видел вполне успешный опыт автоматизации деплоя с помощью Puppet, правда отмечу что для сервиса легко было выбрать время когда пользователи им не пользовались.
Также Ansible и Puppet используют разный подход к предоставляемым абстракциям. Puppet в базовом наборе предоставляет абстракции довольно высокого уровня, например ресурс packet.
Еще одна интересная разность подходов: puppet модули часто содержат в себе несколько классов и ресурсов + иногда дополнительный Ruby код. Например в puppet модуле MySQL может быть класс mysql::prometheus_exporter который выполняет установку и настройку Prometheus экспортера и больше ничего. Если правильно понимаю Ansible то провернуть подобное в составе роли невозможно, Anisible использует философию близкую по духу к Unix-way - роль выполняет только одну задачу и делает это хорошо.

Зависимости:
Некоторые ansible модули требуют наличия на управляемых хостах некоторых python пакетов (например модуль mysql требует наличия pymysql). Обеспечить наличие модулей на местах это задача разработчика роли или playbook'а. Puppet тоже иногда требуются ruby-зависимости для работы модулей но проблему наличия на хостах необходимых ruby компонентов рещают puppetserver вместе с puppet агентом.